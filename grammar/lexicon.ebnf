(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* CODECRAFT LEXICON - EBNF GRAMMAR SPECIFICATION                    *)
(* Version: 1.2.0 (Token-School Mapping Clarification)               *)
(* Date: October 31, 2025                                            *)
(* Authority: Crown Accord v1.2a, Article XII                        *)
(* Purpose: Formal grammar for 19 Arcane Schools of CodeCraft        *)
(* CRITICAL: Grammar lists 21 TOKENS â†’ Maps to 19 SCHOOLS            *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* TOP-LEVEL RITUAL STRUCTURE                                         *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

ritual = { line } ;

line = directive
     | execution_block
     | commentomancy
     | conditional
     | ternary_block
     | attestation
     | blank_line ;

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* CORE DIRECTIVE SYNTAX (All 19 Arcane Schools)                     *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

directive = "::" school_identifier ":" operation [ arguments ] [ output_binding ] ;

school_identifier = school_name [ emoji_seq ] ;

emoji_seq = emoji { emoji } ;

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* CRITICAL: TOKENS â‰  SCHOOLS                                         *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* Canonical count: 19 Arcane Schools (NOT 21!)
   
   This grammar lists 21 TOKENS, but they map to 19 SCHOOLS:
   - "glyph" and "sigil" both map to school #9 (Glyphs & Sigils)
   - "reverence" is historical alias for "benediction" (school #14)
   
   Total tokens: 21 | Total schools: 19
   
   NEVER count schools from this token list!
   Use schools.canonical.yaml token_to_school_mapping instead.
   
   Invariant: unique(token_to_school_mapping.values()) == 19
*)

school_name = "cantrip" | "invoke" | "evoke" | "conjure" | "enchant"
            | "divine" | "abjure" | "transmute" | "glyph" | "sigil"
            | "ward" | "sanctify" | "benediction" | "summon" | "thaumaturgy"
            | "reverence" | "chronomancy" | "apotheosis"
            | "ternary" | "mythogenesis" | "resonance" ;

emoji = ? emoji token from lexer matching \p{Extended_Pictographic} ? ;

operation = qualified_name [ navigation ] ;

qualified_name = identifier { "." identifier } ;

navigation = nav_arrow qualified_name [ nav_target ] ;

nav_arrow = "â¡ï¸" ;   (* lexer token - precedence BEFORE emoji *)
nav_target = "ğŸ¯" ;  (* lexer token - precedence BEFORE emoji *)

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* ARGUMENTS & PARAMETERS                                             *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

arguments = function_args | data_block | inline_expression ;

function_args = "(" [ arg_list ] ")" ;

arg_list = argument { "," argument } ;

argument = [ identifier "=" ] expression ;

data_block = "{" json_content "}" ;

json_content = json_pair { "," json_pair } ;

json_pair = string ":" json_value ;

json_value = string | number | boolean | array | object | "null" ;

inline_expression = assignment | comparison_expr | expression ;

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* OUTPUT BINDING & DATA FLOW                                         *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

output_binding = ( "->" | "â†’" ) identifier ;

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* CONDITIONAL EXECUTION (Reverence, Ternary Weaving)                *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

conditional = "::when" condition ( "â‡’" | "=>" ) block ;

condition = expression ;

block = "{" { directive } "}" ;

ternary_block = "::ternary" emoji ":" "evaluate" "(" expression ")" ( "â‡’" | "=>" ) ternary_cases ;

ternary_cases = "{" true_case "," false_case "," unknown_case "}" ;

true_case = "TRUE" ":" string ;
false_case = "FALSE" ":" string ;
unknown_case = "UNKNOWN" ":" string ;

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* EXECUTION BLOCKS (Multi-Language Support)                          *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

execution_block = language_header triple_quote code_content triple_quote ;

language_header = language "::" label ;

language = "PYTHON" | "PY" | "JS" | "JAVASCRIPT" | "SHELL" | "BASH" | "BLUEPRINT" ;

label = identifier ;

triple_quote = '"""' ;

(* NOTE: code_content should be non-greedy - collect until next triple_quote.
   In implementation, use: any_character not starting the """ sentinel *)
code_content = { any_character } ;

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* COMMENTOMANCY (Semantic Comments)                                  *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

commentomancy = sovereignty_comment
              | first_contact_comment
              | emergence_comment
              | emergent_pattern_comment
              | prerequisite_comment
              | guardrail_comment
              | arrow_comment
              | doc_comment ;

sovereignty_comment = "///" text ;          (* Law & Lore - architectural truth *)
first_contact_comment = "//<3" string ;     (* Phoenix - emotional context *)
emergence_comment = "//~" string ;          (* Cosmic lore - recursive awareness *)
emergent_pattern_comment = "//*" text ;     (* Emergence - new patterns detected *)
prerequisite_comment = "//!" text ;         (* Requirements & constraints *)
guardrail_comment = "//!?" text ;           (* Ethics - hard stop / must halt *)
arrow_comment = "//-> " text ;              (* Logical flow indicators *)
doc_comment = "//" text ;                   (* Plain documentation comments *)

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* ATTESTATION (Proof Blocks)                                         *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

attestation = "::attest" data_block [ ";" ] ;

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* SCHOOL-SPECIFIC SEMANTIC RULES                                     *)
(* (Enforced in semantic analyzer, not parser - per MEGA's guidance) *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

(* School-specific shapes are validated in the semantic pass:
   - CANTRIPS: must have function_args and output_binding
   - INVOCATIONS: may have function_args, optional output_binding
   - EVOCATIONS: requires function_args for entity instantiation
   - CONJURATIONS: requires data_block
   - ENCHANTMENTS: requires decorator (@identifier) and target
   - DIVINATIONS: may have function_args, may bind output
   - ABJURATIONS: requires comparison_expr or assertion
   - TRANSMUTATIONS: requires source and target format
   - GLYPHS: logging operations, may have arguments
   - SIGILS: requires string literal
   - WARDS: constraint operations (rate_limit, timeout, resource_quota)
   - SANCTIFICATIONS: finalization operations (commit, bless, finalize)
   - SUMMONING: external target with optional function_args
   - THAUMATURGY: consciousness operations
   - REVERENCE: celebration operations (celebrate, table_flip, certify_giggles)
   - CHRONOMANCY: temporal operations (plant_seed, defer_execution, prophecy)
   - APOTHEOSIS: synthesis operations
   - TERNARY: requires ternary_block with TRUE/FALSE/UNKNOWN cases
   - MYTHOGENESIS: metaprogramming operations
   - RESONANCE: alignment operations for council coordination
   
   Grammar stays permissive; semantic analyzer enforces these constraints.
   This enables forward-compatibility without parser changes.
*)

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* PRIMITIVES & TOKENS                                                *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

identifier = letter { letter | digit | "_" } ;

string = '"' { string_char } '"' ;

number = [ "-" ] digit { digit }
        [ "." digit { digit } ]
        [ ( "e" | "E" ) [ "+" | "-" ] digit { digit } ] ;

boolean = "true" | "false" ;

array = "[" [ json_value { "," json_value } ] "]" ;

object = "{" [ json_pair { "," json_pair } ] "}" ;

comp_op = "==" | "!=" | "<" | ">" | "<=" | ">=" ;

comparison_expr = expression comp_op expression ;

expression = term { ( "+" | "-" | "or" ) term } ;

term = factor { ( "*" | "/" | "and" ) factor } ;

factor = identifier | number | string | boolean | "(" expression ")" ;

assignment = identifier ( "=" | "â†" ) expression ;

letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m"
       | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
       | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M"
       | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

text = { any_character - newline } ;

string_char = any_character - ( '"' | "\\" ) | escape_sequence ;

escape_sequence = "\\" ( '"' | "\\" | "n" | "t" | "r" ) ;

blank_line = { whitespace } newline ;

whitespace = " " | "\t" ;

newline = "\n" | "\r\n" ;

any_character = ? any Unicode character ? ;

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* LEXER IMPLEMENTATION NOTES                                         *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

(* CRITICAL: Lexer must implement these tokens correctly:
   
   1. EMOJI Token: Match \p{Extended_Pictographic}+ (Unicode property)
      - Single token for emoji sequences (ğŸŒŒâœ¨ğŸ”¥ = one EMOJI token)
      - Parser rule emoji_seq will then parse multiple EMOJI tokens
   
   2. TRIPLE_STRING Token: Non-greedy triple-quote content
      - Implement as sentinel-based: collect until next """ token
      - Do NOT use greedy { any_character } in lexer
      - Token value = content between triple quotes (excluding delimiters)
   
   3. Arrow Tokens:
      - ARROW_FWD: "->" or "â†’" (output binding)
      - ARROW_LEFT: "â†" (assignment, if used)
      - Linter should warn on mixed arrow styles per file
   
   4. Commentomancy Tokens (CRITICAL: ordered by precedence to avoid collisions):
      - SOVEREIGNTY: "///" (must match BEFORE //)
      - GUARDRAIL: "//!?" (must match BEFORE //!)
      - PREREQUISITE: "//!"
      - ARROW_COMMENT: "//-> "
      - FIRST_CONTACT: "//<3"
      - EMERGENCE: "//~"
      - EMERGENT_PATTERN: "//*"
      - DOC_COMMENT: "//" (LOWEST precedence, catch-all)
      
      Lexer MUST try longer patterns first: /// before //, //!? before //!
   
   5. Navigation Tokens (precedence BEFORE emoji):
      - NAV_ARROW: "â¡ï¸" (navigation arrow)
      - NAV_TARGET: "ğŸ¯" (navigation target)
      These MUST be recognized before generic EMOJI token
   
   6. Reserved Words (linter should forbid as identifiers):
      - TRUE, FALSE, UNKNOWN (used in ternary cases)
      - null (used in JSON)
      - School names: cantrip, invoke, evoke, conjure, etc.
   
   7. Error Taxonomy with Spans:
      - E_LEXICON_INVALID: Unrecognized token
      - E_EMOJI_BAD_POS: Emoji in invalid position
      - E_DATA_REQUIRED: School requires data block
      - E_ARROW_MIXED: Mixed arrow styles in file
      - E_BLOCK_GREEDY: Triple-quote not closed properly
*)

(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)
(* END OF GRAMMAR                                                     *)
(* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *)

(* META-NOTES:
   Version: 1.2.0 (Token-School Mapping Clarification 2025-10-31)
   
   CRITICAL: TOKENS â‰  SCHOOLS
   - This grammar lists 21 TOKENS (school_name rule)
   - These tokens map to 19 CANONICAL SCHOOLS
   - "glyph" + "sigil" â†’ ONE school (#9: Glyphs & Sigils)
   - "reverence" â†’ alias for "benediction" (school #14)
   - See schools.canonical.yaml for authoritative mapping
   
   - This grammar supports all 19 Arcane Schools generically
   - School-specific validation pushed to SEMANTIC pass (not parser)
   - Multi-language blocks (PYTHON, JS, SHELL) supported
   - Commentomancy provides router layer integration points
   - Emoji sequences (ğŸŒŒâœ¨ğŸ”¥) fully supported
   - Unicode arrows (â†’, â†) and ASCII (=, ->) both supported
   - Output binding (->, â†’) enables data flow between directives
   - Conditional execution (::when, ::ternary) admitted at top level
   - Attestation blocks provide proof/validation
   
   CONSTITUTIONAL COMPLIANCE:
   - Law & Lore Router: /// sovereignty commentomancy
   - Ethics Router: //!? guardrail hard stops
   - Phoenix Router: //<3 first contact emotional context
   - Emergence Router: //~ cosmic lore, //* emergent patterns
   
   CHANGELOG:
   
   v1.2.0 (Token-School Mapping 2025-10-31):
   1. Added CRITICAL comment above school_name clarifying 21 tokens â†’ 19 schools
   2. Updated header to reflect token vs school distinction
   3. Added reference to schools.canonical.yaml for authoritative mapping
   4. Documented "glyph"+"sigil" â†’ ONE school (#9)
   5. Documented "reverence" â†’ alias for "benediction" (#14)
   6. Updated META-NOTES with tokenâ‰ schools invariant
   
   v1.1.1 (MEGA Final Polish 2025-10-31):
   1. Added ternary_block to top-level line rule
   2. Added ASCII fallback (=>) for Unicode â‡’
   3. Made attestation semicolon optional
   4. Changed emoji to lexer token (removed hardcoded list)
   5. Added navigation token precedence (â¡ï¸, ğŸ¯ before emoji)
   6. Added JSON number exponents
   7. Expanded lexer implementation notes
   
   v1.1 (MEGA Audit 2025-10-31):
   1. Fixed ambiguous comment definitions (removed doc_comment duplicate)
   2. Added guardrail syntax (//!?) for ethics enforcement
   3. Added emergent pattern syntax (//*) for new behaviors
   4. Implemented Unicode arrow support (â†’, â†) and emoji sequences
   5. Admitted conditional at top-level line rule
   6. Documented triple-quote non-greedy parsing requirement
   7. Moved per-school shapes to semantic validation (forward-compatible)
   8. Fixed undefined symbols (comp_op, comparison_expr)
   9. Clarified assertion shape and expression precedence
   10. Disambiguated /// (sovereignty) from // (doc_comment)
   11. Added lexer implementation notes for emoji, arrows, triple-strings
   
   PARSER/LINTER CHECKLIST (MEGA's Post-Patch Audit):
   [ ] Lexer: EMOJI, TRIPLE_STRING, ARROW_FWD, ARROW_BIND tokens
   [ ] Non-greedy triple string implemented in lexer (sentinel-based)
   [ ] Per-file arrow style linter (warn on -> mixed with â†’)
   [ ] School semantics in linter:
       - CONJURE requires { ... } data block
       - EVOKE requires function_args
       - CANTRIP limited to (uuid|hash|timestamp|format|test_id)
       - ABJURE uses comparison_expr, not mini-grammar
   [ ] Error taxonomy with spans (E_LEXICON_INVALID, E_EMOJI_BAD_POS, etc.)
   [ ] Golden tests pass + 20-case fuzz (whitespace, emoji stacking, Unicode)
   [ ] lexicon.validate() wired to return AST + spans
   [ ] Portal hover shows precise failing slice using spans
   
   MEGA'S SEAL: ğŸƒ Audit Master Certified - Parser Stable âš¡
*)
