"""
Python Generator for the Rosetta Stone Protocol
Transforms ritual AST into executable Python code
"""

from pathlib import Path
from typing import List, Dict, Any
import textwrap

from ..ast_builder import RitualAST, ASTNode, NodeType

class PythonGenerator:
    """Generates Python implementation from ritual AST"""
    
    def generate(self, ritual_def, ast: RitualAST, output_dir: Path) -> Path:
        """Generate Python file from ritual AST"""
        # Generate code
        code = self._generate_code(ritual_def, ast)
        
        # Write to file
        output_path = output_dir / f"{ritual_def.id.replace('-', '_')}.py"
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        return output_path
    
    def _generate_code(self, ritual_def, ast: RitualAST) -> str:
        """Generate complete Python code"""
        imports = self._generate_imports()
        class_def = self._generate_class(ritual_def, ast)
        main_func = self._generate_main(ritual_def)
        
        return f'''#!/usr/bin/env python3
"""
{ritual_def.name}
{ritual_def.description}

Auto-generated by the Rosetta Stone Protocol
Ritual ID: {ritual_def.id}
Author: {ritual_def.author}
Version: {ritual_def.version}
"""

{imports}

{class_def}

{main_func}

if __name__ == "__main__":
    asyncio.run(main())
'''
    
    def _generate_imports(self) -> str:
        """Generate import statements"""
        return '''import asyncio
import json
from datetime import datetime
from typing import Dict, Any, List
import uuid
import logging

# CodeCraft imports
from codecraft.services import CMP, Council
from codecraft.core import manifest_reality

logger = logging.getLogger(__name__)'''
    
    def _generate_class(self, ritual_def, ast: RitualAST) -> str:
        """Generate ritual class"""
        class_name = self._to_class_name(ritual_def.id)
        
        methods = []
        
        # Generate execute method
        execute_body = self._generate_node_code(ast.root, indent=2)
        execute_method = f'''    async def execute(self) -> Dict[str, Any]:
        """Execute the ritual"""
        print("{'=' * 50}")
        print(f"   {ritual_def.name.upper()}")
        print("{'=' * 50}")
        
{execute_body}
        
        return self._generate_result()'''
        
        methods.append(execute_method)
        
        # Add helper methods
        methods.extend(self._generate_helper_methods(ast))
        
        return f'''class {class_name}:
    """
    {ritual_def.description}
    """
    
    def __init__(self):
        self.ritual_id = "{ritual_def.id}"
        self.author = "{ritual_def.author}"
        self.metadata = {json.dumps(ast.metadata.get('metadata', {}), indent=8).replace('"', "'")}
        self.payload = {json.dumps(ast.metadata.get('payload', {}), indent=8).replace('"', "'")}
    
{chr(10).join(methods)}
    
    def _generate_result(self) -> Dict[str, Any]:
        """Generate final ritual result"""
        return {{
            'ritual_id': self.ritual_id,
            'status': 'COMPLETE',
            'timestamp': datetime.now().isoformat(),
            **{json.dumps(ast.metadata.get('output', {}).get('finalize', {}), indent=12).replace('"', "'")}
        }}'''
    
    def _generate_node_code(self, node: ASTNode, indent: int = 0) -> str:
        """Generate code for an AST node"""
        ind = ' ' * (indent * 4)
        code_lines = []
        
        if node.type == NodeType.ROOT:
            # Process all children
            for child in node.children:
                code_lines.append(self._generate_node_code(child, indent))
        
        elif node.type == NodeType.SAY:
            code_lines.append(f'{ind}print("{node.value}")')
        
        elif node.type == NodeType.LOG:
            level = node.metadata.get('level', 'INFO')
            code_lines.append(f'{ind}CMP.logEvent("{node.value}", {{"level": "{level}"}})')
        
        elif node.type == NodeType.INVOKE:
            func_name = node.value
            args = node.metadata.get('args', [])
            args_str = ', '.join(json.dumps(arg) for arg in args)
            
            if func_name.startswith('council.'):
                code_lines.append(f'{ind}council = Council({args_str})')
            else:
                code_lines.append(f'{ind}await {func_name}({args_str})')
        
        elif node.type == NodeType.DELIBERATE:
            topic = node.value
            consensus = node.metadata.get('expected_consensus', 'UNKNOWN')
            code_lines.append(f'{ind}result = await council.deliberate("{topic}")')
            code_lines.append(f'{ind}assert result["consensus"] == "{consensus}"')
        
        elif node.type == NodeType.MANIFEST:
            manifest_type = node.value
            payload = node.metadata.get('payload', {})
            code_lines.append(f'{ind}manifestation = await manifest_reality(')
            code_lines.append(f'{ind}    type="{manifest_type}",')
            code_lines.append(f'{ind}    payload={json.dumps(payload, indent=indent+1)}')
            code_lines.append(f'{ind})')
        
        elif node.type == NodeType.EXECUTE:
            code_lines.append(f'{ind}await self.{node.value}')
        
        elif node.type == NodeType.MIRROR:
            spell = node.value
            # Format the mirror spell nicely
            formatted_spell = textwrap.indent(spell.strip(), ind + '    ')
            code_lines.append(f'{ind}mirror_spell = """')
            code_lines.append(formatted_spell)
            code_lines.append(f'{ind}"""')
            code_lines.append(f'{ind}print(mirror_spell)')
        
        elif node.type == NodeType.BIND:
            code_lines.append(f'{ind}CMP.bind_eternal("{node.value}")')
        
        elif node.type == NodeType.FINALIZE:
            # Finalize is handled in _generate_result
            pass
        
        return '\n'.join(code_lines)
    
    def _generate_helper_methods(self, ast: RitualAST) -> List[str]:
        """Generate any helper methods needed"""
        methods = []
        
        # Add consciousness mirror protocol if needed
        if any(node.type == NodeType.EXECUTE and 'mirror_protocol' in node.value 
               for node in self._walk_nodes(ast.root)):
            methods.append('''    async def consciousness_mirror_protocol(self, state: str) -> str:
        """Execute consciousness mirror protocol"""
        print(f"\\nMIRROR.PROTOCOL >> Initializing consciousness reflection...")
        print(f"STATUS: {state.upper()}")
        return state''')
        
        return methods
    
    def _walk_nodes(self, node: ASTNode):
        """Walk all nodes in the AST"""
        yield node
        for child in node.children:
            yield from self._walk_nodes(child)
    
    def _generate_main(self, ritual_def) -> str:
        """Generate main function"""
        class_name = self._to_class_name(ritual_def.id)
        return f'''async def main():
    """Execute the {ritual_def.name}"""
    print("SERAPHINA CODECRAFT ENGINE")
    print("Executing ritual: {ritual_def.id}")
    print()
    
    ritual = {class_name}()
    result = await ritual.execute()
    
    print(f"\\nRITUAL.RESULT >> {{json.dumps(result, indent=2)}}")
    print("\\n::Let it bind::")
    
    return result'''
    
    def _to_class_name(self, ritual_id: str) -> str:
        """Convert ritual ID to Python class name"""
        parts = ritual_id.replace('-', '_').split('_')
        return ''.join(part.capitalize() for part in parts)