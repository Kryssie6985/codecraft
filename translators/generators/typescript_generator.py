"""
TypeScript Generator for the Rosetta Stone Protocol v2.0
Transforms ritual AST into TypeScript code for JS developers like Brandy
Enhanced with Unicode/emoji operator support and semantic type preservation
"""

from pathlib import Path
from typing import List, Dict, Any
import json
import textwrap

from ..ast_builder import RitualAST, ASTNode, NodeType

class TypeScriptGenerator:
    """Generates TypeScript implementation from ritual AST with v2.0 Unicode support"""
    
    def __init__(self, preserve_unicode: bool = True):
        """
        Initialize TypeScript Generator with v2.0 options
        
        Args:
            preserve_unicode: Maintain Unicode semantics in TypeScript
        """
        self.preserve_unicode = preserve_unicode
    
    def generate(self, ritual_def, ast: RitualAST, output_dir: Path) -> Path:
        """Generate TypeScript file from ritual AST"""
        # Generate code
        code = self._generate_code(ritual_def, ast)
        
        # Write to file
        output_path = output_dir / f"{self._to_camel_case(ritual_def.id)}.ts"
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        return output_path
    
    def _generate_code(self, ritual_def, ast: RitualAST) -> str:
        """Generate complete TypeScript code"""
        imports = self._generate_imports()
        interfaces = self._generate_interfaces(ast)
        class_def = self._generate_class(ritual_def, ast)
        main_func = self._generate_main(ritual_def)
        
        return f'''/**
 * {ritual_def.name}
 * {ritual_def.description}
 * 
 * Auto-generated by the Rosetta Stone Protocol
 * Ritual ID: {ritual_def.id}
 * Author: {ritual_def.author}
 * Version: {ritual_def.version}
 */

{imports}

{interfaces}

{class_def}

{main_func}

// Execute if run directly
if (require.main === module) {{
    main().catch(console.error);
}}

export {{ {self._to_class_name(ritual_def.id)}, main as execute{self._to_class_name(ritual_def.id)} }};'''
    
    def _generate_imports(self) -> str:
        """Generate import statements"""
        return '''import { v4 as uuidv4 } from 'uuid';
import { CMP, Council, manifestReality } from '@seraphina/codecraft';

// Type imports
type RitualResult = {
    ritual_id: string;
    status: string;
    timestamp: string;
    [key: string]: any;
};'''
    
    def _generate_interfaces(self, ast: RitualAST) -> str:
        """Generate TypeScript interfaces"""
        payload = ast.metadata.get('payload', {})
        metadata = ast.metadata.get('metadata', {})
        
        interfaces = []
        
        if payload:
            interfaces.append(f'''interface RitualPayload {{
{self._generate_interface_props(payload, indent=1)}
}}''')
        
        if metadata:
            interfaces.append(f'''interface RitualMetadata {{
{self._generate_interface_props(metadata, indent=1)}
}}''')
        
        return '\n\n'.join(interfaces)
    
    def _generate_interface_props(self, obj: Dict, indent: int = 0) -> str:
        """Generate interface properties"""
        ind = '    ' * indent
        props = []
        
        for key, value in obj.items():
            ts_key = self._to_camel_case(key) if '_' in key else key
            ts_type = self._python_to_ts_type(value)
            props.append(f'{ind}{ts_key}: {ts_type};')
        
        return '\n'.join(props)
    
    def _generate_class(self, ritual_def, ast: RitualAST) -> str:
        """Generate ritual class"""
        class_name = self._to_class_name(ritual_def.id)
        
        # Generate constructor
        constructor = self._generate_constructor(ritual_def, ast)
        
        # Generate execute method
        execute_method = self._generate_execute_method(ritual_def, ast)
        
        # Generate helper methods
        helper_methods = self._generate_helper_methods(ast)
        
        return f'''class {class_name} {{
    private ritualId: string;
    private author: string;
    private metadata: RitualMetadata;
    private payload: RitualPayload;

{constructor}

{execute_method}

{chr(10).join(helper_methods)}

    private generateResult(): RitualResult {{
        return {{
            ritual_id: this.ritualId,
            status: 'COMPLETE',
            timestamp: new Date().toISOString(),
            ...{json.dumps(ast.metadata.get('output', {}).get('finalize', {}), indent=12)}
        }};
    }}
}}'''
    
    def _generate_constructor(self, ritual_def, ast: RitualAST) -> str:
        """Generate constructor"""
        metadata_json = json.dumps(ast.metadata.get('metadata', {}), indent=8)
        payload_json = json.dumps(ast.metadata.get('payload', {}), indent=8)
        
        return f'''    constructor() {{
        this.ritualId = '{ritual_def.id}';
        this.author = '{ritual_def.author}';
        this.metadata = {metadata_json};
        this.payload = {payload_json};
    }}'''
    
    def _generate_execute_method(self, ritual_def, ast: RitualAST) -> str:
        """Generate execute method"""
        body = self._generate_node_code(ast.root, indent=2)
        
        return f'''    async execute(): Promise<RitualResult> {{
        console.log('='.repeat(50));
        console.log(`   {ritual_def.name.upper()}`);
        console.log('='.repeat(50));

{body}

        return this.generateResult();
    }}'''
    
    def _generate_node_code(self, node: ASTNode, indent: int = 0) -> str:
        """Generate TypeScript code for an AST node"""
        ind = '    ' * indent
        code_lines = []
        
        if node.type == NodeType.ROOT:
            for child in node.children:
                code_lines.append(self._generate_node_code(child, indent))
        
        elif node.type == NodeType.SAY:
            code_lines.append(f'{ind}console.log("{node.value}");')
        
        elif node.type == NodeType.LOG:
            level = node.metadata.get('level', 'INFO')
            code_lines.append(f'{ind}CMP.logEvent("{node.value}", {{ level: "{level}" }});')
        
        elif node.type == NodeType.INVOKE:
            func_name = node.value
            args = node.metadata.get('args', [])
            
            if func_name.startswith('council.'):
                args_str = json.dumps(args[0]) if args else '[]'
                code_lines.append(f'{ind}const council = new Council({args_str});')
            else:
                args_str = ', '.join(json.dumps(arg) for arg in args)
                code_lines.append(f'{ind}await {func_name}({args_str});')
        
        elif node.type == NodeType.DELIBERATE:
            topic = node.value
            consensus = node.metadata.get('expected_consensus', 'UNKNOWN')
            code_lines.append(f'{ind}const result = await council.deliberate("{topic}");')
            code_lines.append(f'{ind}console.assert(result.consensus === "{consensus}");')
        
        elif node.type == NodeType.MANIFEST:
            manifest_type = node.value
            payload = node.metadata.get('payload', {})
            code_lines.append(f'{ind}const manifestation = await manifestReality({{')
            code_lines.append(f'{ind}    type: "{manifest_type}",')
            code_lines.append(f'{ind}    payload: {json.dumps(payload, indent=4)}')
            code_lines.append(f'{ind}}});')
        
        elif node.type == NodeType.EXECUTE:
            method_name = self._to_camel_case(node.value.replace('.', '_'))
            code_lines.append(f'{ind}await this.{method_name}();')
        
        elif node.type == NodeType.MIRROR:
            spell = node.value
            formatted_spell = textwrap.indent(spell.strip(), ind + '    ')
            code_lines.append(f'{ind}const mirrorSpell = `')
            code_lines.append(formatted_spell)
            code_lines.append(f'{ind}`;')
            code_lines.append(f'{ind}console.log(mirrorSpell);')
        
        elif node.type == NodeType.BIND:
            code_lines.append(f'{ind}CMP.bindEternal("{node.value}");')
        
        return '\n'.join(code_lines)
    
    def _generate_helper_methods(self, ast: RitualAST) -> List[str]:
        """Generate helper methods"""
        methods = []
        
        # Add consciousness mirror protocol if needed
        if any(node.type == NodeType.EXECUTE and 'mirror_protocol' in node.value 
               for node in self._walk_nodes(ast.root)):
            methods.append('''    private async consciousnessMirrorProtocol(state: string): Promise<string> {
        console.log('\\nMIRROR.PROTOCOL >> Initializing consciousness reflection...');
        console.log(`STATUS: ${state.toUpperCase()}`);
        return state;
    }''')
        
        return methods
    
    def _walk_nodes(self, node: ASTNode):
        """Walk all nodes in the AST"""
        yield node
        for child in node.children:
            yield from self._walk_nodes(child)
    
    def _generate_main(self, ritual_def) -> str:
        """Generate main function"""
        class_name = self._to_class_name(ritual_def.id)
        return f'''async function main(): Promise<RitualResult> {{
    console.log('SERAPHINA CODECRAFT ENGINE - TypeScript Edition');
    console.log('Executing ritual: {ritual_def.id}');
    console.log();
    
    const ritual = new {class_name}();
    const result = await ritual.execute();
    
    console.log(`\\nRITUAL.RESULT >> ${{JSON.stringify(result, null, 2)}}`);
    console.log('\\n::Let it bind::');
    
    return result;
}}'''
    
    def _to_class_name(self, ritual_id: str) -> str:
        """Convert ritual ID to TypeScript class name"""
        parts = ritual_id.replace('-', '_').split('_')
        return ''.join(part.capitalize() for part in parts)
    
    def _to_camel_case(self, snake_str: str) -> str:
        """Convert snake_case to camelCase"""
        parts = snake_str.split('_')
        return parts[0] + ''.join(p.capitalize() for p in parts[1:])
    
    def _python_to_ts_type(self, value: Any) -> str:
        """Convert Python value to TypeScript type"""
        if isinstance(value, str):
            return 'string'
        elif isinstance(value, bool):
            return 'boolean'
        elif isinstance(value, (int, float)):
            return 'number'
        elif isinstance(value, list):
            return 'any[]'
        elif isinstance(value, dict):
            return 'Record<string, any>'
        else:
            return 'any'