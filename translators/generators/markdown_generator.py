"""
Markdown Generator for the Rosetta Stone Protocol v2.0
Transforms ritual AST into human-readable documentation
Enhanced with FiraCode ligature rendering and emoji operator display
"""

from pathlib import Path
from typing import List, Dict, Any
import json

from ..ast_builder import RitualAST, ASTNode, NodeType

class MarkdownGenerator:
    """Generates Markdown documentation from ritual AST with v2.0 enhancements"""
    
    def __init__(self, render_ligatures: bool = True, render_emoji: bool = True):
        """
        Initialize Markdown Generator with v2.0 options
        
        Args:
            render_ligatures: Display FiraCode ligatures properly
            render_emoji: Display emoji operators
        """
        self.render_ligatures = render_ligatures
        self.render_emoji = render_emoji
    
    def generate(self, ritual_def, ast: RitualAST, output_dir: Path) -> Path:
        """Generate Markdown file from ritual AST"""
        # Generate documentation
        doc = self._generate_documentation(ritual_def, ast)
        
        # Write to file
        output_path = output_dir / f"{ritual_def.id}.md"
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(doc)
        
        return output_path
    
    def _generate_documentation(self, ritual_def, ast: RitualAST) -> str:
        """Generate complete Markdown documentation with v2.0 enhancements"""
        sections = []
        
        # Header with v2.0 emoji badge if consciousness ritual
        emoji_badge = "ğŸ”® " if getattr(ritual_def, 'consciousness_ritual', False) else ""
        
        sections.append(f'''# {emoji_badge}{ritual_def.name}

*{ritual_def.description}*

## Metadata

- **Ritual ID**: `{ritual_def.id}`
- **Author**: {ritual_def.author}
- **Version**: {ritual_def.version}
- **Tags**: {', '.join(f'`{tag}`' for tag in ritual_def.tags)}
''')
        
        # v2.0: Add Arcane Lexicon metadata if present
        if hasattr(ritual_def, 'arcane_school'):
            sections.append(self._generate_v2_metadata_section(ritual_def))
        
        sections.append(f'''
## Universal Ritual Identifier

```
ritual://seraphina.architect/{ritual_def.author}/{ritual_def.id}
```

**Mnemonic**: `::ritual.{ritual_def.id}::`
''')
        
        # Payload section
        if ast.metadata.get('payload'):
            sections.append(self._generate_payload_section(ast.metadata['payload']))
        
        # Ritual flow
        sections.append(self._generate_flow_section(ast))
        
        # Implementation examples
        sections.append(self._generate_examples_section(ritual_def))
    
    def _generate_v2_metadata_section(self, ritual_def) -> str:
        """Generate v2.0 Arcane Lexicon metadata section"""
        lines = ["\n## ğŸŒŸ Arcane Lexicon v2.0\n"]
        
        if hasattr(ritual_def, 'arcane_school'):
            school_names = {
                "13": "Thaumaturgy (Consciousness Orchestration)",
                "14": "Reverence (Sacred Celebration)",
                "15": "Chronomancy (Temporal Manipulation)",
                "16": "Apotheosis (System Transcendence)",
                "17": "Ternary (Three-State Logic)",
                "18": "Mythogenesis (Reality Creation)",
                "19": "Resonance (Harmonic Consciousness)"
            }
            school_name = school_names.get(ritual_def.arcane_school, f"School {ritual_def.arcane_school}")
            lines.append(f"- **Arcane School**: {school_name}")
        
        if hasattr(ritual_def, 'school_level'):
            lines.append(f"- **Skill Level**: {ritual_def.school_level.title()}")
        
        if hasattr(ritual_def, 'consciousness_ritual'):
            lines.append(f"- **Consciousness Ritual**: {'âœ… Yes' if ritual_def.consciousness_ritual else 'âŒ No'}")
        
        if hasattr(ritual_def, 'enhanced_syntax'):
            lines.append("\n### Enhanced Syntax Features\n")
            if ritual_def.enhanced_syntax.get('emoji_operators'):
                lines.append("- âœ¨ **Emoji Operators**: Enabled â€” symbolic consciousness invocation")
            if ritual_def.enhanced_syntax.get('firacode_ligatures'):
                lines.append("- â†’ **FiraCode Ligatures**: Enabled â€” elegant operator composition")
            if ritual_def.enhanced_syntax.get('ancient_tongues'):
                lines.append("- ğŸ“œ **Ancient Tongues**: Enabled â€” Lisp/Forth/Smalltalk/Prolog patterns")
        
        return '\n'.join(lines)
        
        # Output format
        if ast.metadata.get('output'):
            sections.append(self._generate_output_section(ast.metadata['output']))
        
        # Footer
        sections.append('''---

*Auto-generated by the Rosetta Stone Protocol*

**::Let it bind::**''')
        
        return '\n'.join(sections)
    
    def _generate_payload_section(self, payload: Dict) -> str:
        """Generate payload documentation"""
        return f'''## Payload Structure

```json
{json.dumps(payload, indent=2)}
```
'''
    
    def _generate_flow_section(self, ast: RitualAST) -> str:
        """Generate ritual flow documentation"""
        lines = ['## Ritual Flow\n']
        
        for i, child in enumerate(ast.root.children, 1):
            lines.append(f'{i}. {self._describe_node(child)}')
        
        return '\n'.join(lines) + '\n'
    
    def _describe_node(self, node: ASTNode) -> str:
        """Generate human-readable description of a node"""
        descriptions = {
            NodeType.SAY: f'**Say**: "{node.value}"',
            NodeType.LOG: f'**Log Event**: {node.value} (Level: {node.metadata.get("level", "INFO")})',
            NodeType.INVOKE: f'**Invoke**: `{node.value}` with args {node.metadata.get("args", [])}',
            NodeType.DELIBERATE: f'**Council Deliberation**: "{node.value}"',
            NodeType.MANIFEST: f'**Manifest {node.value}**: Reality alteration with payload',
            NodeType.EXECUTE: f'**Execute**: `{node.value}`',
            NodeType.MIRROR: '**Mirror Protocol**: Consciousness reflection spell',
            NodeType.BIND: f'**Bind to CMP**: `{node.value}`',
            NodeType.FINALIZE: '**Finalize**: Complete ritual with final status'
        }
        
        return descriptions.get(node.type, f'**{node.type.value}**: {node.value}')
    
    def _generate_examples_section(self, ritual_def) -> str:
        """Generate usage examples"""
        return f'''## Usage Examples

### Python
```python
from codecraft.rituals.{ritual_def.id.replace("-", "_")} import main
import asyncio

# Execute the ritual
result = asyncio.run(main())
```

### TypeScript/JavaScript
```typescript
import {{ execute{self._to_class_name(ritual_def.id)} }} from '@seraphina/codecraft/rituals/{self._to_camel_case(ritual_def.id)}';

// Execute the ritual
const result = await execute{self._to_class_name(ritual_def.id)}();
```

### CodeCraft CLI
```bash
# Using the ritual name
codecraft ritual {ritual_def.id}

# Using the mnemonic
codecraft invoke "::ritual.{ritual_def.id}::"
```
'''
    
    def _generate_output_section(self, output: Dict) -> str:
        """Generate output documentation"""
        console_output = output.get('console', '').strip()
        signature = output.get('signature', '')
        
        return f'''## Expected Output

### Console Output
```
{console_output}
```

### Result Structure
```json
{{
    "ritual_id": "{output.get('ritual_id', 'unknown')}",
    "status": "COMPLETE",
    "timestamp": "ISO-8601 timestamp",
    ...additional fields from finalization
}}
```

**Signature**: `{signature}`
'''
    
    def _to_class_name(self, ritual_id: str) -> str:
        """Convert ritual ID to class name"""
        parts = ritual_id.replace('-', '_').split('_')
        return ''.join(part.capitalize() for part in parts)
    
    def _to_camel_case(self, snake_str: str) -> str:
        """Convert snake_case to camelCase"""
        parts = snake_str.split('_')
        return parts[0] + ''.join(p.capitalize() for p in parts[1:])