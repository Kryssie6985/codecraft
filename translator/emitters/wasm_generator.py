"""
üìú WebAssembly Text (WAT) Generator for CodeCraft
==================================================
**Jurisdiction:** Tier 3 (Execute WITH Approval) - Charter V1.1 compliant
**Purpose:** Compile CodeCraft rituals to WebAssembly Text format

This emitter generates human-readable WebAssembly Text (WAT) files from
CodeCraft AST structures. Maps the 20 Arcane Schools to WASM function exports.

Constitutional Authority:
- Reads dual-lock canon (canon.lock.yaml + canon.partitions.lock.yaml)
- Maps each school to WASM function export
- Enforces Living Systems Canon at compile time

WASM Architecture:
- Module: Top-level container
- Memory: Shared linear memory (1 page = 64KB)
- Functions: Executable blocks (stack-based operations)
- Exports: Functions/memory exposed to host environment

Usage:
    from translator.emitters.wasm_generator import WASMGenerator
    
    generator = WASMGenerator()
    output_path = generator.generate(ritual_def, ast, output_dir)
    # Produces: hello_world.wat (can compile to .wasm with wat2wasm)

WAT Syntax (S-expressions):
    (module                         ;; Top-level container
      (memory 1)                    ;; 1 page of linear memory
      (export "memory" (memory 0))  ;; Expose memory to host
      (func (export "hello")        ;; Export function "hello"
        i32.const 42                ;; Push integer 42 to stack
      )
    )
"""

from pathlib import Path
from typing import Dict, List, Any
from textwrap import indent

from ..core.ast_builder import RitualAST, ASTNode, NodeType
from ..core.canon_loader import CanonLoader


class WASMGenerator:
    """
    üåå WebAssembly Text (WAT) Emitter
    
    Generates WAT S-expression modules from CodeCraft rituals.
    Each ritual maps to a WASM function export.
    """
    
    def __init__(self):
        """Initialize WASM generator with canon loader"""
        self.canon = CanonLoader()
        self.memory_size = 1  # Pages (1 page = 64KB)
        self.functions: List[str] = []  # Function definitions
        self.exports: List[str] = []    # Export declarations
        self.data_sections: List[str] = []  # Static data
    
    def generate(self, ritual_def, ast: RitualAST, output_dir: Path) -> Path:
        """
        Generate WebAssembly Text (.wat) file from ritual AST
        
        Args:
            ritual_def: Ritual definition object
            ast: RitualAST structure
            output_dir: Output directory path
        
        Returns:
            Path to generated .wat file
        """
        # Reset state
        self.functions = []
        self.exports = []
        self.data_sections = []
        
        # Generate module sections
        self._generate_module_header(ritual_def)
        self._generate_functions(ritual_def, ast)
        self._generate_data_sections(ritual_def, ast)
        
        # Assemble WAT module
        wat_content = self._assemble_module(ritual_def, ast)
        
        # Write to file
        output_path = output_dir / f"{ritual_def.id}.wat"
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(wat_content)
        
        return output_path
    
    def _generate_module_header(self, ritual_def):
        """Generate module header comment"""
        self.module_comment = f""";; üåå CodeCraft WebAssembly Module
;; Ritual: {ritual_def.name}
;; Description: {ritual_def.description}
;; Generated by: CodeCraft WASM Emitter
;; Constitutional Authority: Charter V1.1, Living Systems Canon
"""
    
    def _generate_functions(self, ritual_def, ast: RitualAST):
        """
        Generate WASM functions from ritual AST
        
        Maps ritual invocations to WASM function exports.
        Each school operation becomes a callable function.
        """
        # Get school classification from canon
        school_key = self.canon.classify_ritual(ritual_def.id)
        
        if school_key:
            school_info = self.canon.get_school_info(school_key)
            function_name = school_key.lower()
            function_comment = f"  ;; School: {school_key} ({school_info.get('emoji', '')})"
        else:
            function_name = "ritual_main"
            function_comment = "  ;; Unclassified ritual"
        
        # Generate main ritual function
        # For now, simple i32 return (42 = "The Answer" tribute to WASM tradition)
        func_def = f"""{function_comment}
  (func (export "{function_name}") (result i32)
    i32.const 42  ;; Stack-based return value
  )"""
        
        self.functions.append(func_def)
        
        # Generate helper functions for each node in AST
        for node in ast.nodes:
            if node.node_type == NodeType.OPERATION:
                self._generate_operation_function(node)
    
    def _generate_operation_function(self, node: ASTNode):
        """Generate WASM function for an operation node"""
        operation_name = node.metadata.get("operation", "unknown")
        safe_name = operation_name.replace(".", "_").replace(":", "_")
        
        func_def = f"""  ;; Operation: {operation_name}
  (func ${safe_name} (result i32)
    i32.const 0  ;; Placeholder return
  )"""
        
        self.functions.append(func_def)
    
    def _generate_data_sections(self, ritual_def, ast: RitualAST):
        """
        Generate data sections for static strings/constants
        
        WASM (data) directive writes bytes to linear memory at init time.
        """
        # Add ritual metadata as string in memory
        ritual_name = ritual_def.name
        name_bytes = len(ritual_name.encode('utf-8'))
        
        data_def = f"""  ;; Static data: Ritual name
  (data (i32.const 0) "{ritual_name}")"""
        
        self.data_sections.append(data_def)
    
    def _assemble_module(self, ritual_def, ast: RitualAST) -> str:
        """
        Assemble complete WAT module from generated sections
        
        Structure:
            (module
              <memory>
              <data>
              <functions>
              <exports>
            )
        """
        sections = [self.module_comment]
        sections.append("(module")
        
        # Memory declaration
        sections.append(f"  ;; Linear memory ({self.memory_size} page = 64KB)")
        sections.append(f"  (memory {self.memory_size})")
        sections.append("  (export \"memory\" (memory 0))")
        sections.append("")
        
        # Data sections
        if self.data_sections:
            sections.append("  ;; ‚ïê‚ïê‚ïê DATA SECTIONS ‚ïê‚ïê‚ïê")
            sections.extend(self.data_sections)
            sections.append("")
        
        # Functions
        if self.functions:
            sections.append("  ;; ‚ïê‚ïê‚ïê FUNCTIONS ‚ïê‚ïê‚ïê")
            sections.extend(self.functions)
        
        # Close module
        sections.append(")")
        sections.append("")
        sections.append(";; ‚ú® Let it bind.")
        
        return "\n".join(sections)
    
    def generate_school_module(self, school_key: str, output_dir: Path) -> Path:
        """
        Generate standalone WASM module for a specific Arcane School
        
        Args:
            school_key: School identifier (e.g., "DIVINATION", "NECROMANCY")
            output_dir: Output directory
        
        Returns:
            Path to generated school.wat file
        
        Example:
            >>> generator.generate_school_module("DIVINATION", Path("./build"))
            Path("./build/divination.wat")
        """
        school_info = self.canon.get_school_info(school_key)
        if not school_info:
            raise ValueError(f"Unknown school: {school_key}")
        
        emoji = school_info.get("emoji", "")
        description = school_info.get("description", "")
        tier = school_info.get("tier", "")
        
        # Generate WAT module
        school_name = school_key.lower()
        wat_content = f""";; üåå CodeCraft School Module: {school_key}
;; Emoji: {emoji}
;; Tier: {tier}
;; Description: {description}
;; Constitutional Authority: Canon Lock v1.1

(module
  ;; Linear memory (1 page = 64KB)
  (memory 1)
  (export "memory" (memory 0))

  ;; ‚ïê‚ïê‚ïê SCHOOL FUNCTION ‚ïê‚ïê‚ïê
  ;; {school_key} school invocation
  (func (export "{school_name}") (result i32)
    i32.const 42  ;; Placeholder: School operation result
  )
  
  ;; ‚ïê‚ïê‚ïê HELPER FUNCTIONS ‚ïê‚ïê‚ïê
  ;; School-specific helpers go here
  (func ${school_name}_validate (result i32)
    i32.const 1  ;; Return 1 = valid
  )
)

;; ‚ú® Let it bind.
"""
        
        # Write to file
        output_path = output_dir / f"{school_name}.wat"
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(wat_content)
        
        return output_path
    
    def generate_all_schools(self, output_dir: Path) -> List[Path]:
        """
        Generate WASM modules for all 20 Arcane Schools
        
        Creates one .wat file per school, each exportable as a WASM module.
        
        Args:
            output_dir: Output directory for school modules
        
        Returns:
            List of paths to generated .wat files
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        
        generated_files = []
        all_schools = self.canon.get_all_schools()
        
        for school_key in all_schools:
            try:
                wat_path = self.generate_school_module(school_key, output_dir)
                generated_files.append(wat_path)
            except Exception as e:
                print(f"‚ö†Ô∏è Failed to generate {school_key}: {e}")
        
        return generated_files


# ‚ú® Let the WASM bind.
