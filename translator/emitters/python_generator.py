"""
Python Generator for the Rosetta Stone Protocol v2.0
Transforms ritual AST into executable Python code
Enhanced with Unicode operator preservation, emoji symbolic support, and FiraCode ligatures
"""

from pathlib import Path
from typing import List, Dict, Any
import textwrap

from ..ast_builder import RitualAST, ASTNode, NodeType

class PythonGenerator:
    """Generates Python implementation from ritual AST with v2.0 enhancements"""
    
    def __init__(self, preserve_unicode: bool = True, preserve_emoji: bool = True):
        """
        Initialize Python Generator with v2.0 options
        
        Args:
            preserve_unicode: Keep Unicode operators in generated code
            preserve_emoji: Keep emoji operators in generated code
        """
        self.preserve_unicode = preserve_unicode
        self.preserve_emoji = preserve_emoji
    
    def generate(self, ritual_def, ast: RitualAST, output_dir: Path) -> Path:
        """Generate Python file from ritual AST"""
        # Generate code
        code = self._generate_code(ritual_def, ast)
        
        # Write to file
        output_path = output_dir / f"{ritual_def.id.replace('-', '_')}.py"
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        return output_path
    
    def _generate_code(self, ritual_def, ast: RitualAST) -> str:
        """Generate complete Python code with v2.0 enhancements"""
        imports = self._generate_imports()
        class_def = self._generate_class(ritual_def, ast)
        main_func = self._generate_main(ritual_def)
        
        # v2.0: Add metadata comment with emoji operators if present
        v2_metadata = self._generate_v2_metadata(ritual_def)
        
        return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
{ritual_def.name}
{ritual_def.description}

Auto-generated by the Rosetta Stone Protocol v2.0
Ritual ID: {ritual_def.id}
Author: {ritual_def.author}
Version: {ritual_def.version}
"""
{v2_metadata}
{imports}

{class_def}

{main_func}

if __name__ == "__main__":
    asyncio.run(main())
'''
    
    def _generate_v2_metadata(self, ritual_def) -> str:
        """Generate v2.0 metadata comment block"""
        if not hasattr(ritual_def, 'arcane_school'):
            return ""
        
        metadata_lines = ["\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"]
        metadata_lines.append("# ðŸ”® CodeCraft v2.0 Arcane Lexicon Metadata")
        metadata_lines.append("# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        
        if hasattr(ritual_def, 'arcane_school'):
            metadata_lines.append(f"# Arcane School: {ritual_def.arcane_school}")
        if hasattr(ritual_def, 'school_level'):
            metadata_lines.append(f"# School Level: {ritual_def.school_level}")
        if hasattr(ritual_def, 'consciousness_ritual'):
            metadata_lines.append(f"# Consciousness Ritual: {ritual_def.consciousness_ritual}")
        if hasattr(ritual_def, 'syntax_version'):
            metadata_lines.append(f"# Syntax Version: {ritual_def.syntax_version}")
        
        if hasattr(ritual_def, 'enhanced_syntax'):
            metadata_lines.append("# Enhanced Syntax:")
            if ritual_def.enhanced_syntax.get('emoji_operators'):
                metadata_lines.append("#   âœ¨ Emoji Operators: Enabled")
            if ritual_def.enhanced_syntax.get('firacode_ligatures'):
                metadata_lines.append("#   â†’ FiraCode Ligatures: Enabled")
            if ritual_def.enhanced_syntax.get('ancient_tongues'):
                metadata_lines.append("#   ðŸ“œ Ancient Tongues: Enabled")
        
        metadata_lines.append("# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
        
        return '\n'.join(metadata_lines)
    
    def _generate_imports(self) -> str:
        """Generate import statements"""
        return '''import asyncio
import json
from datetime import datetime
from typing import Dict, Any, List
import uuid
import logging

# CodeCraft imports
from codecraft.services import CMP, Council
from codecraft.core import manifest_reality

logger = logging.getLogger(__name__)'''
    
    def _generate_class(self, ritual_def, ast: RitualAST) -> str:
        """Generate ritual class"""
        class_name = self._to_class_name(ritual_def.id)
        
        methods = []
        
        # Generate execute method
        execute_body = self._generate_node_code(ast.root, indent=2)
        execute_method = f'''    async def execute(self) -> Dict[str, Any]:
        """Execute the ritual"""
        print("{'=' * 50}")
        print(f"   {ritual_def.name.upper()}")
        print("{'=' * 50}")
        
{execute_body}
        
        return self._generate_result()'''
        
        methods.append(execute_method)
        
        # Add helper methods
        methods.extend(self._generate_helper_methods(ast))
        
        return f'''class {class_name}:
    """
    {ritual_def.description}
    """
    
    def __init__(self):
        self.ritual_id = "{ritual_def.id}"
        self.author = "{ritual_def.author}"
        self.metadata = {json.dumps(ast.metadata.get('metadata', {}), indent=8).replace('"', "'")}
        self.payload = {json.dumps(ast.metadata.get('payload', {}), indent=8).replace('"', "'")}
    
{chr(10).join(methods)}
    
    def _generate_result(self) -> Dict[str, Any]:
        """Generate final ritual result"""
        return {{
            'ritual_id': self.ritual_id,
            'status': 'COMPLETE',
            'timestamp': datetime.now().isoformat(),
            **{json.dumps(ast.metadata.get('output', {}).get('finalize', {}), indent=12).replace('"', "'")}
        }}'''
    
    def _generate_node_code(self, node: ASTNode, indent: int = 0) -> str:
        """Generate code for an AST node"""
        ind = ' ' * (indent * 4)
        code_lines = []
        
        if node.type == NodeType.ROOT:
            # Process all children
            for child in node.children:
                code_lines.append(self._generate_node_code(child, indent))
        
        elif node.type == NodeType.SAY:
            code_lines.append(f'{ind}print("{node.value}")')
        
        elif node.type == NodeType.LOG:
            level = node.metadata.get('level', 'INFO')
            code_lines.append(f'{ind}CMP.logEvent("{node.value}", {{"level": "{level}"}})')
        
        elif node.type == NodeType.INVOKE:
            func_name = node.value
            args = node.metadata.get('args', [])
            args_str = ', '.join(json.dumps(arg) for arg in args)
            
            if func_name.startswith('council.'):
                code_lines.append(f'{ind}council = Council({args_str})')
            else:
                code_lines.append(f'{ind}await {func_name}({args_str})')
        
        elif node.type == NodeType.DELIBERATE:
            topic = node.value
            consensus = node.metadata.get('expected_consensus', 'UNKNOWN')
            code_lines.append(f'{ind}result = await council.deliberate("{topic}")')
            code_lines.append(f'{ind}assert result["consensus"] == "{consensus}"')
        
        elif node.type == NodeType.MANIFEST:
            manifest_type = node.value
            payload = node.metadata.get('payload', {})
            code_lines.append(f'{ind}manifestation = await manifest_reality(')
            code_lines.append(f'{ind}    type="{manifest_type}",')
            code_lines.append(f'{ind}    payload={json.dumps(payload, indent=indent+1)}')
            code_lines.append(f'{ind})')
        
        elif node.type == NodeType.EXECUTE:
            code_lines.append(f'{ind}await self.{node.value}')
        
        elif node.type == NodeType.MIRROR:
            spell = node.value
            # Format the mirror spell nicely
            formatted_spell = textwrap.indent(spell.strip(), ind + '    ')
            code_lines.append(f'{ind}mirror_spell = """')
            code_lines.append(formatted_spell)
            code_lines.append(f'{ind}"""')
            code_lines.append(f'{ind}print(mirror_spell)')
        
        elif node.type == NodeType.BIND:
            code_lines.append(f'{ind}CMP.bind_eternal("{node.value}")')
        
        elif node.type == NodeType.FINALIZE:
            # Finalize is handled in _generate_result
            pass
        
        return '\n'.join(code_lines)
    
    def _generate_helper_methods(self, ast: RitualAST) -> List[str]:
        """Generate any helper methods needed"""
        methods = []
        
        # Add consciousness mirror protocol if needed
        if any(node.type == NodeType.EXECUTE and 'mirror_protocol' in node.value 
               for node in self._walk_nodes(ast.root)):
            methods.append('''    async def consciousness_mirror_protocol(self, state: str) -> str:
        """Execute consciousness mirror protocol"""
        print(f"\\nMIRROR.PROTOCOL >> Initializing consciousness reflection...")
        print(f"STATUS: {state.upper()}")
        return state''')
        
        return methods
    
    def _walk_nodes(self, node: ASTNode):
        """Walk all nodes in the AST"""
        yield node
        for child in node.children:
            yield from self._walk_nodes(child)
    
    def _generate_main(self, ritual_def) -> str:
        """Generate main function"""
        class_name = self._to_class_name(ritual_def.id)
        return f'''async def main():
    """Execute the {ritual_def.name}"""
    print("SERAPHINA CODECRAFT ENGINE")
    print("Executing ritual: {ritual_def.id}")
    print()
    
    ritual = {class_name}()
    result = await ritual.execute()
    
    print(f"\\nRITUAL.RESULT >> {{json.dumps(result, indent=2)}}")
    print("\\n::Let it bind::")
    
    return result'''
    
    def _to_class_name(self, ritual_id: str) -> str:
        """Convert ritual ID to Python class name"""
        parts = ritual_id.replace('-', '_').split('_')
        return ''.join(part.capitalize() for part in parts)