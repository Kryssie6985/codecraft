"""
Ritual Translator (Lexicon Compiler)
Version: 1.0.0
Author: Kode_Animator
License: MIT

This script implements the "Mind" mandated by protocol
PROT-LEX-COMP-V1.0 (RATIFIED).

It reads a high-level "Lexicon Language" (.cc) file,
consults the 'ritual_grimoire.json', and transpiles it
into a low-level "VM Language" (.compiled.cc) file
that the 'codecraft.js' bootstrapper can execute.
"""

import json
import sys
import re
from pathlib import Path
from typing import Dict

# --- Constants ---
# Place this script under languages/codecraft/seraphina_grimoire/tools/
# So BASE_DIR resolves to languages/codecraft
BASE_DIR = Path(__file__).resolve().parents[2]
GRIMOIRE_PATH = BASE_DIR / "seraphina_grimoire" / "ritual_grimoire.json"
COMPILED_SUFFIX = ".compiled.cc"

# This regex is the heart of the "Level 1" parser.
# It looks for `invoke:some.keyword(param="value", ...)`
# This is a simple first pass; it will need to be made more robust.
LEXICON_INVOKE_REGEX = re.compile(
    r"^\s*invoke:([a-zA-Z0-9._-]+)\s*\((.*?)\)$",
    re.MULTILINE
)

def load_grimoire() -> Dict[str, str]:
    """Loads the compiled ritual dictionary."""
    if not GRIMOIRE_PATH.exists():
        print(f"‚ùå FATAL ERROR: Ritual Grimoire not found at {GRIMOIRE_PATH}")
        print("   Please run `build_grimoire.py` first.")
        sys.exit(1)
        
    try:
        with open(GRIMOIRE_PATH, 'r', encoding='utf-8') as f:
            grimoire = json.load(f)
        print(f"‚úÖ Grimoire loaded. {len(grimoire)} rituals found.")
        return grimoire
    except Exception as e:
        print(f"‚ùå FATAL ERROR: Could not load or parse Grimoire: {e}")
        sys.exit(1)

def generate_vm_block(invocation_key: str, params_str: str, grimoire: Dict[str, str]) -> str:
    """
    Generates the low-level VM Language block for a single invocation.
    
    This is the core "transpiler" logic.
    """
    print(f"  Translating: {invocation_key}")
    
    implementation_path = grimoire.get(invocation_key)
    
    if not implementation_path:
        print(f"‚ö†Ô∏è WARNING: No implementation found for '{invocation_key}' in Grimoire. Skipping.")
        return f"# ‚ùå ERROR: Could not find implementation for {invocation_key}\n"
        
    # Determine the block type (PYTHON::, JS::) from the implementation file extension
    # This is a simple but effective convention.
    file_ext = Path(implementation_path).suffix
    block_type = "UNKNOWN"
    
    if file_ext == ".py":
        block_type = "PYTHON"
    elif file_ext == ".js":
        block_type = "JS"
    
    if block_type == "UNKNOWN":
        print(f"‚ö†Ô∏è WARNING: Unknown implementation type for {implementation_path}. Skipping.")
        return f"# ‚ùå ERROR: Unknown implementation type for {implementation_path}\n"

    # This is the "Target" code generation per Article 3
    # We create a unique block name to avoid collisions
    block_name = f"RITUAL_{invocation_key.replace('.', '_')}"
    
    # TODO: A more robust version would parse the params_str and pass them
    # into the generated script's context.

    lines = [
        "# --- Auto-generated by Ritual Translator ---",
        f"# Source: invoke:{invocation_key}({params_str})",
        f"# Implementation: {implementation_path}",
        f"{block_type}::{block_name}",
        '"""',
        "# This block is a placeholder for the actual ritual execution.",
        "# A full implementation would import and run code from:",
        f"# '{implementation_path}'",
        "#",
        f"# Passed parameters: {params_str}",
        "",
        f"print(\"Executing VM block for: {invocation_key}\")",
        f"print(\"Parameters: {params_str}\")",
        '"""',
        "# --- End of auto-generated block ---",
        "",
    ]
    return "\n".join(lines)

def translate_file(input_file: Path, grimoire: Dict[str, str]) -> bool:
    """Translates a single Lexicon file into a VM file."""
    output_file = input_file.with_suffix(COMPILED_SUFFIX)
    
    print(f"üîÆ Translating '{input_file.name}'...")
    print(f"   Output will be: '{output_file.name}'")
    
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            source_content = f.read()
            
        # We use re.sub to find and replace all `invoke:` blocks
        # The `repl` function does the actual code generation
        def replacer(match):
            invocation_key = match.group(1)
            params_str = match.group(2)
            return generate_vm_block(invocation_key, params_str, grimoire)

        compiled_content = LEXICON_INVOKE_REGEX.sub(replacer, source_content)
        
        # Add a header to the compiled file
        header = f"""#
# ‚ö†Ô∏è AUTO-GENERATED FILE - DO NOT EDIT ‚ö†Ô∏è
#
# This file was transpiled by ritual_translator.py
# Source File: {input_file.name}
#
# This "VM Language" file is what 'codecraft.js' executes.
#

"""
        final_output = header + compiled_content
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(final_output)
            
        print(f"‚úÖ Translation complete: {output_file.name}")
        return True
        
    except Exception as e:
        print(f"‚ùå ERROR: Failed during translation: {e}")
        return False

def main() -> None:
    """Main function to run the translator."""
    if len(sys.argv) < 2:
        print("Usage: python ritual_translator.py <path_to_ritual_file.cc>")
        print("Example: python ritual_translator.py ../../docs/unified_template.md")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    
    if not input_file.exists():
        print(f"‚ùå FATAL ERROR: Input file not found: {input_file}")
        sys.exit(1)
        
    grimoire = load_grimoire()
    
    if not translate_file(input_file, grimoire):
        print("Translation failed.")
        sys.exit(1)
        
    print("Translation successful.")

if __name__ == "__main__":
    main()
